#!/bin/bash

# wmux - Git worktree manager with tmux integration
# Usage: wmux (run from within a git repository)
#
# Features:
#   - List existing worktrees
#   - Create new worktrees
#   - Open worktrees in organized tmux windows
#   - Store worktrees in ~/worktrees/OWNER-REPO-name

# Configuration
WORKTREES_DIR="$HOME/worktrees"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo -e "${RED}Error: Not in a git repository${NC}" >&2
        exit 1
    fi
}

# Function to get the repository owner and name from git remote
get_repo_info() {
    local remote_url
    remote_url=$(git config --get remote.origin.url 2>/dev/null)
    
    if [ -z "$remote_url" ]; then
        echo -e "${RED}Error: No remote 'origin' found${NC}" >&2
        exit 1
    fi
    
    # Parse owner/repo from various URL formats:
    # - git@github.com:owner/repo.git
    # - https://github.com/owner/repo.git
    # - https://github.com/owner/repo
    local owner_repo
    if [[ "$remote_url" =~ git@[^:]+:([^/]+)/(.+)(\.git)?$ ]]; then
        owner_repo="${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
    elif [[ "$remote_url" =~ https?://[^/]+/([^/]+)/(.+)(\.git)?$ ]]; then
        owner_repo="${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
    else
        echo -e "${RED}Error: Could not parse owner/repo from remote URL: $remote_url${NC}" >&2
        exit 1
    fi
    
    echo "$owner_repo"
}

# Function to get list of existing worktrees
get_worktrees() {
    # Get worktrees in format: /path/to/worktree branch-name
    git worktree list --porcelain | awk '
        /^worktree / { path = substr($0, 10) }
        /^branch / { branch = substr($0, 8); gsub(/^refs\/heads\//, "", branch) }
        /^$/ { if (path && branch) print path ";" branch; path=""; branch="" }
    '
}

# Function to check if tmux session exists
session_exists() {
    local session_name="$1"
    tmux has-session -t "$session_name" 2>/dev/null
}

# Function to ensure session exists
ensure_session() {
    local session_name="$1"
    local base_path="$2"
    
    if ! session_exists "$session_name"; then
        echo -e "${BLUE}Creating new tmux session: $session_name${NC}" >&2
        # Create session with a temporary window
        tmux new-session -d -s "$session_name" -c "$base_path" 'sleep 1'
        sleep 0.1
    else
        echo -e "${GREEN}Using existing tmux session: $session_name${NC}" >&2
    fi
}

# Function to get worktree name from path
get_worktree_name() {
    local worktree_path="$1"
    basename "$worktree_path"
}

# Function to create new worktree
create_new_worktree() {
    local owner="$1"
    local repo="$2"
    
    echo -e "${BLUE}Creating new worktree${NC}" >&2
    
    # Prompt for worktree name
    local worktree_name
    worktree_name=$(gum input --prompt "Worktree name > " --placeholder "feature-name")
    
    if [ -z "$worktree_name" ]; then
        echo -e "${RED}No worktree name provided${NC}" >&2
        exit 1
    fi
    
    # Sanitize worktree name (replace spaces with hyphens, lowercase)
    worktree_name=$(echo "$worktree_name" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
    
    local worktree_path="$WORKTREES_DIR/$owner-$repo-$worktree_name"
    
    # Check if worktree directory already exists
    if [ -d "$worktree_path" ]; then
        echo -e "${RED}Error: Worktree directory already exists: $worktree_path${NC}" >&2
        exit 1
    fi
    
    # Prompt for base branch
    local base_branch
    local default_branch
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    if [ -z "$default_branch" ]; then
        default_branch="main"
    fi
    
    base_branch=$(gum input --prompt "Base branch > " --placeholder "$default_branch" --value "$default_branch")
    
    if [ -z "$base_branch" ]; then
        base_branch="$default_branch"
    fi
    
    # Create worktrees directory if it doesn't exist
    mkdir -p "$WORKTREES_DIR"
    
    echo -e "${BLUE}Creating worktree at: $worktree_path${NC}" >&2
    echo -e "${BLUE}From branch: $base_branch${NC}" >&2
    
    # Create the worktree
    if git worktree add "$worktree_path" -b "$worktree_name" "$base_branch" >&2; then
        echo -e "${GREEN}Successfully created worktree: $worktree_name${NC}" >&2
        echo "$worktree_path"
    else
        echo -e "${RED}Failed to create worktree${NC}" >&2
        exit 1
    fi
}

# Function to format worktree for display
format_worktree_display() {
    local worktree_path="$1"
    local branch="$2"
    local worktree_name
    worktree_name=$(get_worktree_name "$worktree_path")
    
    # Format: worktree-name (branch-name)
    echo "$worktree_name ($branch)"
}

# Main function
main() {
    check_git_repo
    
    # Get repository info
    local repo_info
    repo_info=$(get_repo_info)
    local owner=$(echo "$repo_info" | cut -d'/' -f1)
    local repo=$(echo "$repo_info" | cut -d'/' -f2)
    
    echo -e "${YELLOW}Repository: $owner/$repo${NC}" >&2
    
    # Get existing worktrees
    local worktrees
    worktrees=$(get_worktrees)
    
    # Build menu options with embedded paths (format: "display_name|||path")
    local menu_items=""
    
    # Add existing worktrees to menu
    while IFS=';' read -r path branch; do
        if [ -n "$path" ] && [ -n "$branch" ]; then
            local display_name
            display_name=$(format_worktree_display "$path" "$branch")
            
            # Embed path in the menu item using ||| as separator
            local menu_item="$display_name|||$path"
            
            if [ -z "$menu_items" ]; then
                menu_items="$menu_item"
            else
                menu_items="$menu_items
$menu_item"
            fi
        fi
    done <<< "$worktrees"
    
    # Add option to create new worktree
    local new_option="+ Create new worktree"
    if [ -z "$menu_items" ]; then
        menu_items="$new_option"
    else
        menu_items="$menu_items
$new_option"
    fi
    
    # Show menu (strip the |||path part for display only)
    local selected
    selected=$(echo "$menu_items" | sed 's/|||.*//' | gum filter --prompt 'worktree >' --placeholder '')
    
    if [ -z "$selected" ]; then
        echo -e "${RED}No worktree selected${NC}" >&2
        exit 1
    fi
    
    # Check for uncommitted changes before switching
    local has_changes=false
    if ! git diff-index --quiet HEAD 2>/dev/null || [ -n "$(git ls-files --others --exclude-standard)" ]; then
        has_changes=true
    fi
    
    # Handle selection
    local worktree_path
    local worktree_name
    local window_name
    local stash_name=""
    
    if [ "$selected" = "$new_option" ]; then
        # Ask about stashing changes before creating new worktree
        if [ "$has_changes" = true ]; then
            echo -e "${YELLOW}You have uncommitted changes.${NC}" >&2
            local take_changes
            take_changes=$(gum choose --header "Take changes to new worktree?" "Yes" "No")
            
            if [ "$take_changes" = "Yes" ]; then
                stash_name="wmux-temp-$(date +%s)"
                echo -e "${BLUE}Stashing changes as: $stash_name${NC}" >&2
                git stash push -u -m "$stash_name" >&2
            fi
        fi
        
        # Create new worktree
        worktree_path=$(create_new_worktree "$owner" "$repo")
        worktree_name=$(get_worktree_name "$worktree_path")
        feature_name="${worktree_name#$owner-$repo-}"
    else
        # Ask about stashing changes before switching to existing worktree
        if [ "$has_changes" = true ]; then
            echo -e "${YELLOW}You have uncommitted changes.${NC}" >&2
            local take_changes
            take_changes=$(gum choose --header "Take changes to selected worktree?" "Yes" "No")
            
            if [ "$take_changes" = "Yes" ]; then
                stash_name="wmux-temp-$(date +%s)"
                echo -e "${BLUE}Stashing changes as: $stash_name${NC}" >&2
                git stash push -u -m "$stash_name" >&2
            fi
        fi
        
        # Use existing worktree - extract path from menu items
        worktree_path=$(echo "$menu_items" | grep -F "$selected|||" | sed 's/.*|||//')
        worktree_name=$(get_worktree_name "$worktree_path")
        feature_name="${worktree_name#$owner-$repo-}"
        echo -e "${GREEN}Selected worktree: $worktree_name${NC}" >&2
    fi
    
    # Apply stash in the new worktree if we stashed changes
    if [ -n "$stash_name" ]; then
        echo -e "${BLUE}Applying stash in new worktree...${NC}" >&2
        (cd "$worktree_path" && git stash apply "stash^{/$stash_name}" && git stash drop "stash^{/$stash_name}") >&2
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Successfully applied changes to new worktree${NC}" >&2
        else
            echo -e "${YELLOW}Warning: Could not apply stash automatically. You may need to resolve conflicts.${NC}" >&2
            echo -e "${YELLOW}Stash preserved as: $stash_name${NC}" >&2
        fi
    fi
    
    # Create window name in format: repo|feature
    window_name="$repo|$feature_name"
    
    # Ensure session exists (use owner as session name)
    local session_name="$owner"
    ensure_session "$session_name" "$WORKTREES_DIR"
    
    # Use tmux-window script to create/switch to window
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    
    if [ ! -x "$script_dir/tmux-window" ]; then
        echo -e "${RED}Error: tmux-window script not found or not executable${NC}" >&2
        echo -e "${YELLOW}Expected at: $script_dir/tmux-window${NC}" >&2
        exit 1
    fi
    
    "$script_dir/tmux-window" "$session_name" "$window_name" "$worktree_path"
}

# Run main function
main "$@"
