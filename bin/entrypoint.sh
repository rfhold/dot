#!/bin/bash
set -e

# =============================================================================
# Container Entrypoint
# Starts sshd in the background, then execs into the provided command
# =============================================================================

# Setup PATH to include user-installed tools
export PATH="/usr/local/go/bin:$HOME/go/bin:$HOME/.bun/bin:$HOME/.local/bin:$HOME/.cargo/bin:$PATH"

SSH_HOST_KEY_DIR="${SSH_HOST_KEY_DIR:-/etc/ssh}"
SSH_HOST_KEY_TYPES="rsa ecdsa ed25519"
RUNTIME_ENV_FILE="$HOME/.env.runtime"

# -----------------------------------------------------------------------------
# Persist runtime env vars for SSH sessions
# -----------------------------------------------------------------------------
setup_runtime_env() {
    # List of env vars to make available in SSH sessions
    local vars_to_persist=(
        OPENCODE_SERVER_PASSWORD
    )
    
    # Create runtime env file
    echo "# Runtime environment - sourced by shell on SSH login" > "$RUNTIME_ENV_FILE"
    echo "# Generated by entrypoint at $(date -Iseconds)" >> "$RUNTIME_ENV_FILE"
    
    for var in "${vars_to_persist[@]}"; do
        if [[ -n "${!var}" ]]; then
            echo "export ${var}=\"${!var}\"" >> "$RUNTIME_ENV_FILE"
        fi
    done
    
    chmod 600 "$RUNTIME_ENV_FILE"
    echo "[entrypoint] Runtime env vars written to $RUNTIME_ENV_FILE"
}

# -----------------------------------------------------------------------------
# Generate SSH host keys if not present
# -----------------------------------------------------------------------------
generate_host_keys() {
    local generated=false
    local user_key="$HOME/.ssh/id_ed25519"
    local conf_key="$HOME/.ssh-conf/id_ed25519"
    local host_ed25519_key="${SSH_HOST_KEY_DIR}/ssh_host_ed25519_key"
    
    # Check for ed25519 key in either location (prefer .ssh, fall back to .ssh-conf)
    local source_key=""
    if [[ -f "$user_key" ]]; then
        source_key="$user_key"
    elif [[ -f "$conf_key" ]]; then
        source_key="$conf_key"
    fi
    
    # If user's ed25519 key exists, use it as the host key for consistent identity
    if [[ -n "$source_key" && ! -f "$host_ed25519_key" ]]; then
        echo "[entrypoint] Using ed25519 key as host key for consistent identity"
        sudo cp "$source_key" "$host_ed25519_key"
        sudo chown root:root "$host_ed25519_key"
        sudo chmod 600 "$host_ed25519_key"
        if [[ -f "${source_key}.pub" ]]; then
            sudo cp "${source_key}.pub" "${host_ed25519_key}.pub"
        else
            # Generate public key from private key
            sudo ssh-keygen -y -f "$host_ed25519_key" | sudo tee "${host_ed25519_key}.pub" > /dev/null
        fi
        sudo chown root:root "${host_ed25519_key}.pub"
        sudo chmod 644 "${host_ed25519_key}.pub"
    fi
    
    for type in $SSH_HOST_KEY_TYPES; do
        local key_path="${SSH_HOST_KEY_DIR}/ssh_host_${type}_key"
        if [[ ! -f "$key_path" ]]; then
            echo "[entrypoint] Generating ${type} host key..."
            sudo ssh-keygen -t "$type" -f "$key_path" -N "" -q
            generated=true
        fi
    done
    
    if [[ "$generated" == "true" ]]; then
        echo "[entrypoint] WARNING: SSH host keys were generated fresh."
        echo "[entrypoint] For persistent identity, mount keys to ${SSH_HOST_KEY_DIR}/"
        echo "[entrypoint] Example: -v /path/to/keys:/etc/ssh/host_keys:ro"
    fi
}

# -----------------------------------------------------------------------------
# Setup and update dotfiles repo
# -----------------------------------------------------------------------------
update_dotfiles() {
    local dot_dir="$HOME/dot"
    local remote_url="git@git.holdenitdown.net:rfhold/dot.git"
    
    # If no .git directory, initialize git connection
    # The Docker image has the files but not .git (excluded via .dockerignore)
    if [[ ! -d "$dot_dir/.git" ]]; then
        echo "[entrypoint] Initializing git repo at $dot_dir..."
        
        cd "$dot_dir"
        
        # Clone just the .git directory to a temp location, then move it over
        # This avoids issues with git init seeing existing files as dirty
        local tmp_git=$(mktemp -d)
        
        # Accept new host keys automatically (first connection to git server)
        export GIT_SSH_COMMAND="ssh -o StrictHostKeyChecking=accept-new"
        
        if git clone --bare "$remote_url" "$tmp_git" 2>/dev/null; then
            # Move the bare repo contents into .git
            mkdir -p .git
            mv "$tmp_git"/* .git/
            rm -rf "$tmp_git"
            
            # Convert from bare to normal repo
            git config --local --bool core.bare false
            
            # Reset index to match HEAD - files already match from Docker build
            git reset HEAD -- . >/dev/null 2>&1 || true
            
            # Set up branch tracking
            git branch --set-upstream-to=origin/main main 2>/dev/null || true
            
            echo "[entrypoint] Git repo initialized and connected to origin"
        else
            rm -rf "$tmp_git"
            echo "[entrypoint] Could not clone from origin (network or SSH key issue)"
            echo "[entrypoint] Continuing without git tracking"
        fi
        
        cd - >/dev/null
        return 0
    fi
    
    cd "$dot_dir"
    
    # Setup origin if not configured
    if ! git remote get-url origin &>/dev/null; then
        echo "[entrypoint] Setting up origin: $remote_url"
        git remote add origin "$remote_url"
    fi
    
    # Try to pull latest changes
    echo "[entrypoint] Checking for dotfiles updates..."
    local before_sha=$(git rev-parse HEAD 2>/dev/null || echo "none")
    
    if git pull --ff-only origin main 2>/dev/null; then
        local after_sha=$(git rev-parse HEAD)
        
        if [[ "$before_sha" != "$after_sha" ]]; then
            echo "[entrypoint] Dotfiles updated ($before_sha -> $after_sha)"
            echo "[entrypoint] Running update.sh..."
            if [[ -x "$dot_dir/bin/update.sh" ]]; then
                "$dot_dir/bin/update.sh"
            fi
        else
            echo "[entrypoint] Dotfiles already up to date"
        fi
    else
        echo "[entrypoint] Could not pull dotfiles (network or SSH key issue), continuing with existing version"
    fi
    
    cd - >/dev/null
}

# -----------------------------------------------------------------------------
# Setup SSH directory from mounted config
# -----------------------------------------------------------------------------
setup_ssh_dir() {
    local conf_dir="$HOME/.ssh-conf"
    local ssh_dir="$HOME/.ssh"
    
    # K8s secret mounts have wrong permissions (world-readable, root-owned)
    # sshd with StrictModes rejects these. Copy to ~/.ssh with correct perms.
    if [[ -d "$conf_dir" ]]; then
        # Create .ssh directory with correct permissions
        mkdir -p "$ssh_dir"
        chmod 700 "$ssh_dir"
        
        # Copy all files from conf dir
        for file in "$conf_dir"/*; do
            [[ -f "$file" ]] && cp "$file" "$ssh_dir/"
        done
        
        # Set correct permissions
        chmod 600 "$ssh_dir"/* 2>/dev/null || true
        chmod 644 "$ssh_dir"/*.pub 2>/dev/null || true
        
        if [[ -f "$ssh_dir/authorized_keys" ]]; then
            chmod 600 "$ssh_dir/authorized_keys"
            echo "[entrypoint] SSH directory configured from $conf_dir"
        else
            echo "[entrypoint] WARNING: No authorized_keys in $conf_dir"
        fi
    elif [[ -f "$ssh_dir/authorized_keys" ]]; then
        # Keys already in .ssh (direct mount or previous setup)
        chmod 700 "$ssh_dir"
        chmod 600 "$ssh_dir/authorized_keys"
        echo "[entrypoint] SSH authorized_keys configured"
    else
        echo "[entrypoint] WARNING: No SSH config found"
        echo "[entrypoint] SSH login will not be possible without keys"
        echo "[entrypoint] Mount keys to: $conf_dir"
    fi
}

# -----------------------------------------------------------------------------
# Setup known hosts for common Git providers
# -----------------------------------------------------------------------------
setup_known_hosts() {
    local ssh_dir="$HOME/.ssh"
    local known_hosts="$ssh_dir/known_hosts"
    
    mkdir -p "$ssh_dir"
    chmod 700 "$ssh_dir"
    
    # Add GitHub's host key if not already present
    if ! grep -q "^github.com" "$known_hosts" 2>/dev/null; then
        echo "[entrypoint] Adding GitHub to known_hosts..."
        ssh-keyscan github.com >> "$known_hosts" 2>/dev/null
    fi
    
    chmod 600 "$known_hosts" 2>/dev/null || true
}

# -----------------------------------------------------------------------------
# Start sshd
# -----------------------------------------------------------------------------
start_sshd() {
    echo "[entrypoint] Starting sshd..."
    sudo /usr/sbin/sshd -e
    echo "[entrypoint] sshd started on port 22"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
main() {
    setup_ssh_dir
    generate_host_keys
    setup_known_hosts
    update_dotfiles
    setup_runtime_env
    start_sshd
    
    # If no command provided, just keep the container alive
    # (user can SSH in to interact)
    if [[ $# -eq 0 ]]; then
        echo "[entrypoint] No command specified, container running with SSH access only"
        echo "[entrypoint] Connect via: ssh -p <port> $(whoami)@<host>"
        # Sleep forever - sshd handles connections in background
        exec sleep infinity
    fi
    
    echo "[entrypoint] Executing: $*"
    exec "$@"
}

main "$@"
