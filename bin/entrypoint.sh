#!/bin/bash
set -e

# =============================================================================
# Container Entrypoint
# Starts sshd in the background, then execs into the provided command
# =============================================================================

# Setup PATH to include user-installed tools
export PATH="/usr/local/go/bin:$HOME/go/bin:$HOME/.bun/bin:$HOME/.local/bin:$HOME/.cargo/bin:$PATH"

SSH_HOST_KEY_DIR="${SSH_HOST_KEY_DIR:-/etc/ssh}"
SSH_HOST_KEY_TYPES="rsa ecdsa ed25519"
RUNTIME_ENV_FILE="$HOME/.env.runtime"

# -----------------------------------------------------------------------------
# Persist runtime env vars for SSH sessions
# -----------------------------------------------------------------------------
setup_runtime_env() {
    # List of env vars to make available in SSH sessions
    local vars_to_persist=(
        OPENCODE_SERVER_PASSWORD
    )
    
    # Create runtime env file
    echo "# Runtime environment - sourced by shell on SSH login" > "$RUNTIME_ENV_FILE"
    echo "# Generated by entrypoint at $(date -Iseconds)" >> "$RUNTIME_ENV_FILE"
    
    for var in "${vars_to_persist[@]}"; do
        if [[ -n "${!var}" ]]; then
            echo "export ${var}=\"${!var}\"" >> "$RUNTIME_ENV_FILE"
        fi
    done
    
    chmod 600 "$RUNTIME_ENV_FILE"
    echo "[entrypoint] Runtime env vars written to $RUNTIME_ENV_FILE"
}

# -----------------------------------------------------------------------------
# Generate SSH host keys if not present
# -----------------------------------------------------------------------------
generate_host_keys() {
    local generated=false
    local user_key="$HOME/.ssh/id_ed25519"
    local conf_key="$HOME/.ssh-conf/id_ed25519"
    local host_ed25519_key="${SSH_HOST_KEY_DIR}/ssh_host_ed25519_key"
    
    # Check for ed25519 key in either location (prefer .ssh, fall back to .ssh-conf)
    local source_key=""
    if [[ -f "$user_key" ]]; then
        source_key="$user_key"
    elif [[ -f "$conf_key" ]]; then
        source_key="$conf_key"
    fi
    
    # If user's ed25519 key exists, use it as the host key for consistent identity
    if [[ -n "$source_key" && ! -f "$host_ed25519_key" ]]; then
        echo "[entrypoint] Using ed25519 key as host key for consistent identity"
        sudo cp "$source_key" "$host_ed25519_key"
        sudo chown root:root "$host_ed25519_key"
        sudo chmod 600 "$host_ed25519_key"
        if [[ -f "${source_key}.pub" ]]; then
            sudo cp "${source_key}.pub" "${host_ed25519_key}.pub"
        else
            # Generate public key from private key
            sudo ssh-keygen -y -f "$host_ed25519_key" | sudo tee "${host_ed25519_key}.pub" > /dev/null
        fi
        sudo chown root:root "${host_ed25519_key}.pub"
        sudo chmod 644 "${host_ed25519_key}.pub"
    fi
    
    for type in $SSH_HOST_KEY_TYPES; do
        local key_path="${SSH_HOST_KEY_DIR}/ssh_host_${type}_key"
        if [[ ! -f "$key_path" ]]; then
            echo "[entrypoint] Generating ${type} host key..."
            sudo ssh-keygen -t "$type" -f "$key_path" -N "" -q
            generated=true
        fi
    done
    
    if [[ "$generated" == "true" ]]; then
        echo "[entrypoint] WARNING: SSH host keys were generated fresh."
        echo "[entrypoint] For persistent identity, mount keys to ${SSH_HOST_KEY_DIR}/"
        echo "[entrypoint] Example: -v /path/to/keys:/etc/ssh/host_keys:ro"
    fi
}

# -----------------------------------------------------------------------------
# Setup and update dotfiles repo
# -----------------------------------------------------------------------------
update_dotfiles() {
    local dot_dir="$HOME/dot"
    local remote_url="git@git.holdenitdown.net:rfhold/dot.git"
    
    # If no .git directory, initialize git connection
    # The Docker image has the files but not .git (excluded via .dockerignore)
    if [[ ! -d "$dot_dir/.git" ]]; then
        echo "[entrypoint] Initializing git repo at $dot_dir..."
        
        cd "$dot_dir"
        
        # Clone just the .git directory to a temp location, then move it over
        # This avoids issues with git init seeing existing files as dirty
        local tmp_git=$(mktemp -d)
        
        # Accept new host keys automatically (first connection to git server)
        export GIT_SSH_COMMAND="ssh -o StrictHostKeyChecking=accept-new"
        
        if git clone --bare "$remote_url" "$tmp_git" 2>/dev/null; then
            # Move the bare repo contents into .git
            mkdir -p .git
            mv "$tmp_git"/* .git/
            rm -rf "$tmp_git"
            
            # Convert from bare to normal repo
            git config --local --bool core.bare false
            
            # Bare clones don't have a fetch refspec - add it so fetch works
            git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'
            
            # Create remote tracking refs (bare clone doesn't have refs/remotes/*)
            git fetch origin 2>/dev/null || true
            
            # Reset index to match HEAD - files already match from Docker build
            git reset HEAD -- . >/dev/null 2>&1 || true
            
            # Set up branch tracking
            git branch --set-upstream-to=origin/main main 2>/dev/null || true
            
            echo "[entrypoint] Git repo initialized and connected to origin"
        else
            rm -rf "$tmp_git"
            echo "[entrypoint] Could not clone from origin (network or SSH key issue)"
            echo "[entrypoint] Continuing without git tracking"
        fi
        
        cd - >/dev/null
        return 0
    fi
    
    cd "$dot_dir"
    
    # Setup origin if not configured
    if ! git remote get-url origin &>/dev/null; then
        echo "[entrypoint] Setting up origin: $remote_url"
        git remote add origin "$remote_url"
    fi
    
    # Try to pull latest changes
    echo "[entrypoint] Checking for dotfiles updates..."
    local before_sha=$(git rev-parse HEAD 2>/dev/null || echo "none")
    
    if git pull --ff-only origin main 2>/dev/null; then
        local after_sha=$(git rev-parse HEAD)
        
        if [[ "$before_sha" != "$after_sha" ]]; then
            echo "[entrypoint] Dotfiles updated ($before_sha -> $after_sha)"
            echo "[entrypoint] Running update.sh..."
            if [[ -x "$dot_dir/bin/update.sh" ]]; then
                "$dot_dir/bin/update.sh"
            fi
        else
            echo "[entrypoint] Dotfiles already up to date"
        fi
    else
        echo "[entrypoint] Could not pull dotfiles (network or SSH key issue), continuing with existing version"
    fi
    
    cd - >/dev/null
}

# -----------------------------------------------------------------------------
# Setup SSH directory from mounted config
# -----------------------------------------------------------------------------
setup_ssh_dir() {
    local conf_dir="$HOME/.ssh-conf"
    local ssh_dir="$HOME/.ssh"
    
    # K8s secret mounts have wrong permissions (world-readable, root-owned)
    # sshd with StrictModes rejects these. Copy to ~/.ssh with correct perms.
    if [[ -d "$conf_dir" ]]; then
        # Create .ssh directory with correct permissions
        mkdir -p "$ssh_dir"
        chmod 700 "$ssh_dir"
        
        # Copy all files from conf dir
        for file in "$conf_dir"/*; do
            [[ -f "$file" ]] && cp "$file" "$ssh_dir/"
        done
        
        # Set correct permissions
        chmod 600 "$ssh_dir"/* 2>/dev/null || true
        chmod 644 "$ssh_dir"/*.pub 2>/dev/null || true
        
        if [[ -f "$ssh_dir/authorized_keys" ]]; then
            chmod 600 "$ssh_dir/authorized_keys"
            echo "[entrypoint] SSH directory configured from $conf_dir"
        else
            echo "[entrypoint] WARNING: No authorized_keys in $conf_dir"
        fi
    elif [[ -f "$ssh_dir/authorized_keys" ]]; then
        # Keys already in .ssh (direct mount or previous setup)
        chmod 700 "$ssh_dir"
        chmod 600 "$ssh_dir/authorized_keys"
        echo "[entrypoint] SSH authorized_keys configured"
    else
        echo "[entrypoint] WARNING: No SSH config found"
        echo "[entrypoint] SSH login will not be possible without keys"
        echo "[entrypoint] Mount keys to: $conf_dir"
    fi
}

# -----------------------------------------------------------------------------
# Setup known hosts for common Git providers
# -----------------------------------------------------------------------------
setup_known_hosts() {
    local ssh_dir="$HOME/.ssh"
    local known_hosts="$ssh_dir/known_hosts"
    
    mkdir -p "$ssh_dir"
    chmod 700 "$ssh_dir"
    
    # Add GitHub's host key if not already present
    if ! grep -q "^github.com" "$known_hosts" 2>/dev/null; then
        echo "[entrypoint] Adding GitHub to known_hosts..."
        ssh-keyscan github.com >> "$known_hosts" 2>/dev/null
    fi
    
    chmod 600 "$known_hosts" 2>/dev/null || true
}

# -----------------------------------------------------------------------------
# Setup container engine access (Docker socket, DinD, Kubernetes)
# -----------------------------------------------------------------------------
setup_container_access() {
    # Docker socket mounted from host
    if [[ -S /var/run/docker.sock ]]; then
        echo "[entrypoint] Docker socket detected at /var/run/docker.sock"
        # Get the GID of the docker socket
        # Use stat -c for Linux, stat -f for macOS/BSD
        local docker_gid
        if docker_gid=$(stat -c '%g' /var/run/docker.sock 2>/dev/null); then
            : # Linux stat succeeded
        elif docker_gid=$(stat -f '%g' /var/run/docker.sock 2>/dev/null); then
            : # BSD stat succeeded
        else
            echo "[entrypoint] WARNING: Could not determine docker socket GID"
            docker_gid=""
        fi
        
        if [[ -n "$docker_gid" ]]; then
            # Create docker group with matching GID if it doesn't exist
            if ! getent group "$docker_gid" >/dev/null 2>&1; then
                sudo groupadd -g "$docker_gid" docker 2>/dev/null || true
            fi
            # Add current user to the docker group
            sudo usermod -aG "$docker_gid" "$(whoami)" 2>/dev/null || true
            echo "[entrypoint] Added user to docker group (gid $docker_gid)"
        fi
    fi

    # DinD via DOCKER_HOST environment variable
    if [[ -n "${DOCKER_HOST:-}" ]]; then
        echo "[entrypoint] DOCKER_HOST is set: $DOCKER_HOST"
        # Verify connectivity
        if docker info &>/dev/null; then
            echo "[entrypoint] Docker daemon reachable via DOCKER_HOST"
        else
            echo "[entrypoint] WARNING: DOCKER_HOST set but cannot connect to daemon"
        fi
    fi

    # Kubernetes in-cluster configuration
    if [[ -f /var/run/secrets/kubernetes.io/serviceaccount/token ]]; then
        echo "[entrypoint] Kubernetes service account detected"
        local kube_token kube_ca kube_ns
        kube_token=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
        kube_ca=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        kube_ns=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace 2>/dev/null || echo "default")
        
        mkdir -p ~/.kube
        
        # Configure kubectl for in-cluster access
        kubectl config set-cluster in-cluster \
            --server=https://kubernetes.default.svc \
            --certificate-authority="$kube_ca" \
            --embed-certs=true 2>/dev/null || true
        kubectl config set-credentials serviceaccount \
            --token="$kube_token" 2>/dev/null || true
        kubectl config set-context default \
            --cluster=in-cluster \
            --user=serviceaccount \
            --namespace="$kube_ns" 2>/dev/null || true
        kubectl config use-context default 2>/dev/null || true
        
        echo "[entrypoint] Kubernetes config written to ~/.kube/config (namespace: $kube_ns)"
    fi
}

# -----------------------------------------------------------------------------
# Run bootstrap if not already done (for bootstrap-on-start images)
# -----------------------------------------------------------------------------
run_bootstrap_if_needed() {
    local bootstrap_marker="$HOME/.bootstrap-complete"
    local bootstrap_script="$HOME/dot/bin/bootstrap.sh"
    
    if [[ -f "$bootstrap_marker" ]]; then
        echo "[entrypoint] Bootstrap already completed"
        return 0
    fi
    
    if [[ ! -x "$bootstrap_script" ]]; then
        echo "[entrypoint] WARNING: Bootstrap script not found at $bootstrap_script"
        return 1
    fi
    
    echo "[entrypoint] Running first-time bootstrap (this may take a few minutes)..."
    if "$bootstrap_script"; then
        touch "$bootstrap_marker"
        echo "[entrypoint] Bootstrap completed successfully"
    else
        echo "[entrypoint] WARNING: Bootstrap failed, will retry on next start"
        return 1
    fi
}

# -----------------------------------------------------------------------------
# Start sshd
# -----------------------------------------------------------------------------
start_sshd() {
    echo "[entrypoint] Starting sshd..."
    # Create privilege separation directory (required for sshd, tmpfs wipes it)
    sudo mkdir -p /run/sshd
    sudo /usr/sbin/sshd -e
    echo "[entrypoint] sshd started on port 22"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
main() {
    setup_ssh_dir
    generate_host_keys
    setup_known_hosts
    setup_container_access
    run_bootstrap_if_needed
    update_dotfiles
    setup_runtime_env
    start_sshd
    
    # Supervisor loop variables
    local PID_FILE="/tmp/app.pid"
    local RESTART_FLAG="/tmp/app-restart-requested"
    
    # If no command provided, just keep the container alive
    # (user can SSH in to interact)
    if [[ $# -eq 0 ]]; then
        echo "[entrypoint] No command specified, container running with SSH access only"
        echo "[entrypoint] Connect via: ssh -p <port> $(whoami)@<host>"
        # Sleep forever - sshd handles connections in background
        exec sleep infinity
    fi
    
    # Supervisor loop with flag-based restart support
    # Use app-restart to signal a restart without restarting the container
    echo "[entrypoint] Starting supervised app: $*"
    echo "[entrypoint] Use 'app-restart' to restart the app without container restart"
    
    while true; do
        "$@" &
        local APP_PID=$!
        echo $APP_PID > "$PID_FILE"
        echo "[entrypoint] App started with PID $APP_PID"
        
        # Wait for the app to exit
        wait $APP_PID || true
        local EXIT_CODE=$?
        
        # Check if restart was requested via app-restart
        if [[ -f "$RESTART_FLAG" ]]; then
            rm -f "$RESTART_FLAG"
            echo "[entrypoint] Restart requested, restarting app..."
            sleep 1
            continue
        fi
        
        # Natural exit - clean up and propagate exit code
        rm -f "$PID_FILE"
        echo "[entrypoint] App exited with code $EXIT_CODE"
        exit $EXIT_CODE
    done
}

main "$@"
