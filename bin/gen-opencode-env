#!/bin/bash

# Generate an encrypted environment file for opencode/ssh box
# Creates:
#   - OPENCODE_SERVER_PASSWORD (random)
#   - SSH_PRIVATE_KEY (ed25519)
#   - SSH_PUBLIC_KEY (ed25519)
#
# Optionally updates GitHub SSH key via gh CLI

set -euo pipefail

# Configuration
DOTFILES_DIR="$HOME/dot"
ENV_DIR="$DOTFILES_DIR/env"
ENV_ENCRYPTED_DIR="$ENV_DIR/encrypted"
ENV_TEMP_DIR="$ENV_DIR/.temp"
DEFAULT_GROUP_NAME="opencode"
DEFAULT_GH_KEY_NAME="opencode"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Create necessary directories
mkdir -p "$ENV_ENCRYPTED_DIR" "$ENV_TEMP_DIR"

# Function to display usage
usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Generate an encrypted environment file for opencode/ssh box.

Options:
    -n, --name NAME       Environment group name (default: $DEFAULT_GROUP_NAME)
    -g, --github          Update GitHub SSH key
    -k, --gh-key-name     GitHub SSH key title (default: $DEFAULT_GH_KEY_NAME)
    -f, --force           Overwrite existing env group without prompting
    -h, --help            Show this help message

Examples:
    $(basename "$0")                      # Create 'opencode' env group
    $(basename "$0") -n mybox             # Create 'mybox' env group
    $(basename "$0") -g                   # Create env and update GitHub
    $(basename "$0") -g -k "dev-container" # Use custom GitHub key name
EOF
    exit 0
}

# Function to get GPG key ID
get_gpg_key() {
    local keys
    keys=$(gpg --list-secret-keys --keyid-format=long 2>/dev/null | grep -E "^sec" | awk '{print $2}' | cut -d'/' -f2)
    if [ -z "$keys" ]; then
        echo -e "${RED}No GPG keys found. Please create one first.${NC}" >&2
        exit 1
    fi
    
    # If multiple keys, let user choose
    local key_count
    key_count=$(echo "$keys" | wc -l | tr -d ' ')
    if [ "$key_count" -gt 1 ]; then
        echo "$keys" | gum choose --header "Select GPG key to use:"
    else
        echo "$keys"
    fi
}

# Function to get GPG key user ID (name <email>)
get_gpg_user_id() {
    local gpg_key="$1"
    # Extract the uid line for the specified key (format: "uid [trust] Name <email>")
    gpg --list-secret-keys --keyid-format=long "$gpg_key" 2>/dev/null | \
        grep "^uid" | \
        head -1 | \
        sed -E 's/^uid[[:space:]]+\[[^]]+\][[:space:]]+//'
}

# Function to generate random password
generate_password() {
    # Generate a 32-character alphanumeric password using openssl
    openssl rand -base64 32 | tr -dc 'A-Za-z0-9' | head -c 32
}

# Function to generate SSH key pair
generate_ssh_keypair() {
    local temp_key_file="$1"
    local comment="$2"
    
    # Generate ed25519 key pair (no passphrase, comment matches GPG identity)
    ssh-keygen -t ed25519 -f "$temp_key_file" -N "" -C "$comment" -q
}

# Function to encrypt env file
encrypt_env_file() {
    local group_name="$1"
    local temp_file="$2"
    local gpg_key="$3"
    local encrypted_file="$ENV_ENCRYPTED_DIR/${group_name}.gpg"
    
    gpg --encrypt --recipient "$gpg_key" --armor --output "$encrypted_file" "$temp_file"
}

# Function to update GitHub SSH key
update_github_ssh_key() {
    local public_key="$1"
    local key_title="$2"
    
    # Check if gh is available
    if ! command -v gh &>/dev/null; then
        echo -e "${RED}Error: gh CLI not found. Install it to use GitHub integration.${NC}" >&2
        return 1
    fi
    
    # Check if authenticated
    if ! gh auth status &>/dev/null; then
        echo -e "${RED}Error: Not authenticated with GitHub. Run 'gh auth login' first.${NC}" >&2
        return 1
    fi
    
    # Check for existing key with same title and delete it
    echo -e "${YELLOW}Checking for existing GitHub SSH key named '$key_title'...${NC}"
    local existing_key_id
    existing_key_id=$(gh ssh-key list --json id,title -q ".[] | select(.title == \"$key_title\") | .id" 2>/dev/null || true)
    
    if [ -n "$existing_key_id" ]; then
        echo -e "${YELLOW}Found existing key, removing...${NC}"
        gh ssh-key delete "$existing_key_id" --yes
    fi
    
    # Add new key
    echo -e "${YELLOW}Adding new SSH key to GitHub...${NC}"
    gh ssh-key add - --title "$key_title" <<< "$public_key"
    
    echo -e "${GREEN}✓ GitHub SSH key updated with title '$key_title'${NC}"
}

# Cleanup function
cleanup() {
    rm -rf "$ENV_TEMP_DIR"
}

# Set trap to cleanup on exit
trap cleanup EXIT

# Parse arguments
GROUP_NAME="$DEFAULT_GROUP_NAME"
GH_KEY_NAME="$DEFAULT_GH_KEY_NAME"
UPDATE_GITHUB=false
FORCE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--name)
            GROUP_NAME="$2"
            shift 2
            ;;
        -g|--github)
            UPDATE_GITHUB=true
            shift
            ;;
        -k|--gh-key-name)
            GH_KEY_NAME="$2"
            shift 2
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}" >&2
            usage
            ;;
    esac
done

# Main script
main() {
    echo -e "${CYAN}OpenCode Environment Generator${NC}"
    echo "================================"
    echo ""
    
    # Check if env group already exists
    local encrypted_file="$ENV_ENCRYPTED_DIR/${GROUP_NAME}.gpg"
    if [ -f "$encrypted_file" ] && [ "$FORCE" != "true" ]; then
        echo -e "${YELLOW}Environment group '$GROUP_NAME' already exists.${NC}"
        if ! gum confirm "Do you want to overwrite it?"; then
            echo -e "${RED}Aborted.${NC}"
            exit 1
        fi
    fi
    
    # Get GPG key
    GPG_KEY=$(get_gpg_key)
    echo -e "${GREEN}Using GPG key:${NC} $GPG_KEY"
    
    # Get GPG user ID for SSH key comment
    GPG_USER_ID=$(get_gpg_user_id "$GPG_KEY")
    echo -e "${GREEN}Using identity:${NC} $GPG_USER_ID"
    echo ""
    
    # Generate password
    echo -e "${YELLOW}Generating OpenCode server password...${NC}"
    OPENCODE_PASSWORD=$(generate_password)
    echo -e "${GREEN}✓ Generated 32-character password${NC}"
    
    # Generate SSH key pair
    echo -e "${YELLOW}Generating SSH key pair (ed25519)...${NC}"
    SSH_KEY_FILE="$ENV_TEMP_DIR/ssh_key_$$"
    generate_ssh_keypair "$SSH_KEY_FILE" "$GPG_USER_ID"
    
    SSH_PRIVATE_KEY=$(cat "$SSH_KEY_FILE")
    SSH_PUBLIC_KEY=$(cat "${SSH_KEY_FILE}.pub")
    # Base64 encode the private key for single-line storage
    SSH_PRIVATE_KEY_B64=$(base64 < "$SSH_KEY_FILE" | tr -d '\n')
    echo -e "${GREEN}✓ Generated SSH key pair${NC}"
    
    # Clean up temp SSH files
    rm -f "$SSH_KEY_FILE" "${SSH_KEY_FILE}.pub"
    
    # Create env file
    echo -e "${YELLOW}Creating environment file...${NC}"
    TEMP_ENV_FILE="$ENV_TEMP_DIR/${GROUP_NAME}.env"
    
    cat > "$TEMP_ENV_FILE" <<EOF
# OpenCode Box Environment
# Generated: $(date -Iseconds)

# OpenCode server password for HTTP basic auth
OPENCODE_SERVER_PASSWORD=$OPENCODE_PASSWORD

# SSH public key (add to authorized_keys)
SSH_PUBLIC_KEY=$SSH_PUBLIC_KEY

# SSH private key (base64 encoded)
# Decode with: echo "\$SSH_PRIVATE_KEY_B64" | base64 -d > ~/.ssh/opencode_key
SSH_PRIVATE_KEY_B64=$SSH_PRIVATE_KEY_B64
EOF
    
    # Encrypt the file
    echo -e "${YELLOW}Encrypting environment file...${NC}"
    encrypt_env_file "$GROUP_NAME" "$TEMP_ENV_FILE" "$GPG_KEY"
    rm -f "$TEMP_ENV_FILE"
    echo -e "${GREEN}✓ Encrypted and saved to:${NC} $encrypted_file"
    echo ""
    
    # Optionally update GitHub
    if [ "$UPDATE_GITHUB" = "true" ]; then
        echo ""
        update_github_ssh_key "$SSH_PUBLIC_KEY" "$GH_KEY_NAME"
    fi
    
    # Summary
    echo ""
    echo -e "${CYAN}Summary${NC}"
    echo "======="
    echo -e "Environment group: ${GREEN}$GROUP_NAME${NC}"
    echo -e "Encrypted file:    ${GREEN}$encrypted_file${NC}"
    echo ""
    echo -e "${YELLOW}To load these variables:${NC}"
    echo -e "  ${GREEN}envl $GROUP_NAME${NC}"
    echo ""
    echo -e "${YELLOW}To view the variables:${NC}"
    echo -e "  ${GREEN}envs $GROUP_NAME${NC}"
    echo ""
    echo -e "${YELLOW}To use the SSH key:${NC}"
    echo -e "  ${GREEN}envl $GROUP_NAME${NC}"
    echo -e "  ${GREEN}echo \"\$SSH_PRIVATE_KEY_B64\" | base64 -d > ~/.ssh/${GROUP_NAME}_key && chmod 600 ~/.ssh/${GROUP_NAME}_key${NC}"
    echo -e "  ${GREEN}ssh -i ~/.ssh/${GROUP_NAME}_key user@host${NC}"
    
    if [ "$UPDATE_GITHUB" != "true" ]; then
        echo ""
        echo -e "${YELLOW}To add SSH key to GitHub later:${NC}"
        echo -e "  ${GREEN}$(basename "$0") -n $GROUP_NAME -g${NC}  (will regenerate)"
        echo -e "  ${GREEN}# Or manually:${NC}"
        echo -e "  ${GREEN}envl $GROUP_NAME && echo \"\$SSH_PUBLIC_KEY\" | gh ssh-key add - --title \"$GH_KEY_NAME\"${NC}"
    fi
}

# Run main function
main
